<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_player</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///create brush
if(!instance_exists(obj_brush))
    instance_create(x,y,obj_brush);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement variable setup
horMovement = 0;
//every step, the player moves this many pixels horizontally (negative moves left)
signCheck = 0;
//used for movement checking
jumpsMade = 0;
//jumps made; limited by NUMJUMPS. Resets on landing.
facing = "right";
//set to either "left" or "right" to indicate which way the player faces
mercyInvincibility = 0;
//hit protection
mercySetting = 120;
//how much to set the time to on hit

//STATE FLAGS
recoilFlag = false;
//if the player is flying from taking a hit; set to false when they land
deadFlag = false;
//whether or not the player is dead and shouldn't do anything
ledgeFlag = false;
//indicates the player is clinging to a ledge
pushFlag = false;
//indicates the player is pushing against something

//CONSTANTS (or close to such)
MOVEMAX = 2; //max movement speed
MOVEINC = 0.25; //increment speed
PUSHMAX = 1; //max movement speed while pushing something
NUMJUMPS = 1; //number of available total jumps
STRJUMP1 = -3.75; //strength of first jump
INCJUMP = 0.36; //subtracted from jumps while the button is held down
CUTJUMP = -2; //vspeed must be less than this to add extra height
STRJUMP2 = -6; //strength of additional jumps
LEDGEJUMP = -2.75; //strength of jumps from clinging to a ledge
RECOILMAX = 5; //recoil maximum speed
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///gravity
gravity_direction = 270; //down
if(ledgeFlag) { //don't fall while holding an edge
    gravity = 0;
}
else if(place_free(x,y+1)) {
    gravity = worldGravity;
    //show_debug_message(string(vspeed));
}
else {
    gravity = 0;
}

//cap falling speed
if(vspeed &gt; 11) vspeed = 11;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///input
//passive buttons (Start and Select)
if(input_check_pressed(input.passive_primary)) {
    //open pause menu
    instance_create(view_xview[0]+view_wview[0]/2,
        view_yview[0]+view_hview[0]/2,
        obj_pause);
}
if(input_check_pressed(input.passive_secondary)) {
    //reorder glyph list
}
//check directional movement
var moveLeft, moveRight, moveUp, moveDown;
if(input_get(input.move_analog)) { //axis input
    //in order for "pressed" and "released" operations to function, the game
    // must manually track when analogue input changes from 0 to not-0 and back
    moveLeft[0] = input_axis(input.move_left) &lt; 0;
    moveLeft[1] = moveLeft[0] &amp;&amp; input_check_pressed(input.move_left);
    moveLeft[2] = moveLeft[0] &amp;&amp; input_check_released(input.move_left);
    moveRight[0] = input_axis(input.move_right) &gt; 0;
    moveRight[1] = moveRight[0] &amp;&amp; input_check_pressed(input.move_right);
    moveRight[2] = moveRight[0] &amp;&amp; input_check_released(input.move_right);
    moveUp[0] = input_axis(input.move_up) &lt; 0;
    moveUp[1] = moveUp[0] &amp;&amp; input_check_pressed(input.move_up);
    moveUp[2] = moveUp[0] &amp;&amp; input_check_released(input.move_up);
    moveDown[0] = input_axis(input.move_down) &gt; 0;
    moveDown[1] = moveDown[0] &amp;&amp; input_check_pressed(input.move_down);
    moveDown[2] = moveDown[0] &amp;&amp; input_check_released(input.move_down);
}
else { //button input
    moveLeft[0] = input_check(input.move_left);
    moveLeft[1] = input_check_pressed(input.move_left);
    moveLeft[2] = input_check_released(input.move_left);
    moveRight[0] = input_check(input.move_right);
    moveRight[1] = input_check_pressed(input.move_right);
    moveRight[2] = input_check_released(input.move_right);
    moveUp[0] = input_check(input.move_up);
    moveUp[1] = input_check_pressed(input.move_up);
    moveUp[2] = input_check_released(input.move_up);
    moveDown[0] = input_check(input.move_down);
    moveDown[1] = input_check_pressed(input.move_down);
    moveDown[2] = input_check_released(input.move_down);
}
if(moveLeft[0]) {
    //move left
    if(!recoilFlag &amp;&amp; !ledgeFlag) {
        horMovement -= MOVEINC;
        facing = "left";
    }
}
if(moveRight[0]) {
    //move right
    if(!recoilFlag &amp;&amp; !ledgeFlag) {
        horMovement += MOVEINC;
        facing = "right";
    }
}
if(moveUp[1]) {
    //
    show_debug_message("pressed UP");
}
if(moveDown[0]) {
    //drop from a ledge
    if(ledgeFlag) {
        ledgeFlag = false;
    }
}
//action buttons (A and B)
if(input_check_pressed(input.action_primary)) {
    //jump
    if(ledgeFlag) { //hop from edge
        vspeed = LEDGEJUMP;
        jumpsMade = 1;
        ledgeFlag = false;
    }
    else if(jumpsMade == 0) { //first jump
        if(!place_free(x,y+1)) {
            vspeed = STRJUMP1; //-8.6
            jumpsMade += 1;
            //show_debug_message(string(vspeed));
        }
    }
    else { //extra jumps
        if(jumpsMade &lt; NUMJUMPS) {
            vspeed = STRJUMP2;
            jumpsMade += 1;
        }
    }
}
if(input_check(input.action_primary)) {
    //variable jump
    if(vspeed &lt; CUTJUMP)
        vspeed -= INCJUMP;
}
if(input_check_pressed(input.action_secondary)) {
    //trigger glyph
    if(ds_list_size(glyphList) &gt; 0) {
        var g = ds_list_find_value(glyphList,0);
        with(g) event_user(0);
        ds_list_delete(glyphList,0);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///movement

//slow movement
if(horMovement != 0 &amp;&amp; !recoilFlag) {
    if(!input_check(input.move_left) &amp;&amp; !input_check(input.move_right)) {
        //slow down
        if(abs(horMovement) &lt;= MOVEINC) {
            horMovement = 0;
        }
        else if(horMovement &lt; 0) { //moving left
            horMovement += MOVEINC;
        }
        else { //moving right
            horMovement -= MOVEINC;
        }
    }
}

//limit horizontal movement
if(recoilFlag)
    horMovement = min(RECOILMAX, max(horMovement, -RECOILMAX));
else if(pushFlag)
    horMovement = min(PUSHMAX, max(horMovement, -PUSHMAX));
else
    horMovement = min(MOVEMAX, max(horMovement, -MOVEMAX));

//move the character
var increment = 1;
signCheck = sign(horMovement) * increment;
pushFlag = false;
if(ledgeFlag) {
    //no movement while holding a ledge
    horMovement = 0;
}
else {
    //check if ledge cling
    var xval = x+signCheck*(sprite_width/2+1),
        ytop = y-(sprite_height/2), ybot = y+(sprite_height/2)-1,
        yper = 0.25,
        yval = y-(sprite_height/2)+(yper*sprite_height);
    if(!collision_line(xval, ytop, xval, yval, obj_wall, false, true) &amp;&amp;
        collision_line(xval, yval, xval, ybot, obj_wall, false, true) &amp;&amp;
        !place_meeting(x,y+sprite_height,obj_wall) &amp;&amp;
        vspeed &gt; 0) {
        vspeed = 0;
        horMovement = 0;
        gravity = 0;
        y = collision_line(xval, yval, xval, ybot, obj_wall, false, true).y + 4;
        ledgeFlag = true;
    }
    else repeat(abs(horMovement)) { //normal movement
    //for(var i = increment; i &lt; abs(horMovement); i += increment) {
        if(place_free(x + signCheck,y)) {
            x += signCheck;
            if(!place_free(x,y+2) &amp;&amp; place_free(x,y+1))
                y += 1;
        }
        else {
            if(place_free(x + signCheck,y - 1)) { //slope
                y -= 1;
                x += signCheck;
            }
            //TODO: if there's a pushable block here that has space past it
            else {
                pushFlag = true;
                var pushBlock = instance_place(x+signCheck,y,obj_wall);
                if(!place_free(x,y+1) //on the ground
                    &amp;&amp; isPushable(pushBlock,signCheck)) {
                    pushBlock.x += signCheck;
                    x += signCheck;
                }
                else { //solid obstruction
                    horMovement = 0;
                    break;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///alpha adjust
if(maxBlots &gt; 0) image_alpha = 0.25 + (0.75* (currentBlots / maxBlots));
else image_alpha = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving to contact in the proper direction
if(other.y &gt; y &amp;&amp; !place_free(x,y+vspeed)) {
    //land on top of
    move_contact_solid(270,11);
    vspeed = 0;
    gravity = 0;
    jumpsMade = 0;
    y = round(y);
}
if(other.y &lt; y &amp;&amp; !place_free(x,y+vspeed)) {
    //hit from below
    move_contact_solid(90,11);
    vspeed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw VOID IMP snapped to pixel grid
draw_sprite_ext(sprite_index,image_index,
    round(x),round(y),
    image_xscale,image_yscale,image_angle,image_blend,image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
